# ファイルメタデータのリフレッシュと先行読み込み改善

## 背景
現在、ox はメインペインで表示中のファイル一覧に対して必要時にメタデータを取得しています。
頻繁なディレクトリ切り替えやタブ移動では、同じディレクトリに対して複数回メタデータ取得が走り、レスポンスが遅く感じられることがあります。
また非アクティブなタブや非表示リストに遷移した瞬間にデータが未取得のまま表示されると、数値が一瞬リセットされるように見える挙動があります。

## 目的
- ユーザーがタブやディレクトリを移動した際のメタデータ表示遅延を減らす。選択移動のタイミングで再取得する前提とする。
- 先行読み込みはアクティブでないタブには行わず、現行選択の前後5アイテムに限る。
- 設計を小さな変更に分解し、API/構造の整合性を保ちながらテスト可能にする。

## 検討すべき課題

### 1. メタデータ取得の現状とコスト
- 現在の仕様ではカーソルが移動したタイミングでのみ再取得する。取得のたびに前後5件以外は破棄。
- 取得トリガーは明示的なので、`fs::metadata` への依存や非同期のたびに新しい制御が欲しい。
- コアロジックで `MetadataSnapshot` を保持し、UI側へ `MetadataUpdate` メッセージを明示的に渡す。

### 2. リフレッシュレート制御
- リフレッシュを気にせず、選択移動時に即座に再取得する。そのため「指定時間経過」ではなく「進行番号」で古い結果を破棄する。
- `AppClock` のような時間注入は不要だが、要求に順番をつける `RequestId` を導入して最新の結果だけ反映させる。
- 連続移動では `RequestId` をインクリメントするだけで、古いレスポンスが返ってきても無視できるようにする。

### 3. 先行読み込み（Prefetch）
- アクティブでないタブやペインへの先行読み込みは行わない。
- 現在選択中のファイルとその前後5件に限り、移動のたびに必要なメタデータを取得。
- 取得の結果は `VecDeque` などで管理し、前後5件以外は即座に `drop` する。

### 4. UIとの協調
- SlackFeedback のように、メタデータの取得結果に応じた状態を `UiMessage` で通知。
- 取得中のステータスを Bottom Bar などで知らせることで、先行読み込みやリフレッシュの効果を視覚化。
- UI は明示的な再取得トリガー（カーソル移動やキーボード操作）を送るだけにして、`MetadataFetcher`/`MetadataWindow` がその要求に応じて `MetadataSnapshot` を生成し、`MetadataUpdate` メッセージで結果を返す。  
- `MetadataSnapshot` のライフサイクルとキャッシュ/バックグラウンド更新はコア側で完結させ、UI 側はメッセージを受け取るタイミングのみを意識する。これにより今後 `MetadataFetcher` にキャッシュや先行更新が追加されても、UI との同期ロジックは `MetadataUpdate` のハンドリング箇所に集中する。

### 5. テストと検証
- フェイク実装で `fs::metadata` の結果に番号 (`RequestId`) を付けて、古い結果が UI に反映しないことを確認する。
- 前後5件の保持ロジックを `VecDeque` などで検証し、選択移動で不要なエントリが落ちることを示す。
- `VecDeque` の `pop_front`/`pop_back` を忘れた場合にメタデータが累積する可能性があるため、stress-test で一定件数を超えたら最古エントリが `drop` されていることを確認する。
- 連続移動時にも最新結果だけ反映されることを統合テストで示す。
- `NotFound` や `PermissionDenied` といったエラーをフェイクで再現し、UI に `MetadataStatus::Error` を出す経路を確認する。
- 強化テストとして「200 回連続移動しても保持件数は常に 11 件以下」「現在選択番号が 15 のとき、範囲外（1~9）のエントリがすべて drop されている」などの定量的検証を追加し、`MetadataWindow` が `VecDeque` の pop 操作を忘れないことを補強する。

## 6. 非同期取得のスロットリングと優先度
- `RequestId` ベースで古いレスポンスを無視するだけでは、IO 負荷が高まる。`Semaphore` ベースのスロットリングで同時取得数を制限する。
- 現在選択中の前後5件に対する取得リクエストは高優先度、それ以外を低優先度とする。ただし permit をそのまま保持してしまう低優先度は優先度キューに入れて待機し、高優先度が到着した際に再分配できるようにする。
- `PriorityQueue` 的な仲介で、permit を確保できるまで高優先度が待機し、低優先度がキャンセルされたり古い `RequestId` で無効になったら即座に permit を返す明示的なシグナリングを行う。
- フェイク `MetadataFetcher` で複数リクエストを用意し、同時実行数が制限されつつ、優先度の高い結果のみが即時反映されることをテストする。low-priority task がキャンセルされたときに permit が確実に返ることも含める。

## 7. 進行番号による制御とキャンセル
- `RequestId` を最新状態に追従させるだけでなく、発行済みリクエストを追跡し、`tokio::sync::watch`/`AbortHandle` などを用いて古いフェッチを優先的に中断する仕組みを導入する。
- キャンセルはメタデータ取得の前段（fetch フェーズ）でハンドリングされ、UI に到達する前に不要な `fs::metadata` を止めることで IO とスレッド負荷を抑止する。
- `MetadataFetcher` は `RequestId` ごとに `AbortHandle` を記録し、カーソル移動で新しい `RequestId` を発行するときは古い handle に `abort` を送る。取得完了時に `RequestId` を確認して必要なら `drop` する流れを維持する。

## 次の小さなステップ（TDD視点）
1. `MetadataFetcher` を抽象化し、`RequestId` を生成・検証できるフェイクを用意する。
2. `VecDeque` で前後5件を維持する `MetadataWindow` を定義し、選択移動で古いメタデータが `drop` される仕様をテストする。
3. 同時取得を制限する `Semaphore` と優先度付き permit の仕組みを実装して、低優先度が待機する状態を確認する。
4. UI と `MetadataStatus` メッセージを通じて、取得中／エラーの状態遷移を Bottom Bar などで描画できるようにする。

## 検証の指標
- 「選択移動後、即座に前後5件が確保されて描画できていること」。
- 「複数の移動で古いレスポンスがあっても、最新結果だけが UI に反映されていること」。
- 「高優先度リクエストが低優先度より先に permit を取得し、低優先度は待機するようになっていること」。

## 実装プラン（TODO）

### 1. 仕様の最小ユニット（TDD）
- [ ] `RequestId` の責務を定義し、生成と比較だけを行う小さな型にする。
- [ ] `RequestId` の単体テストを先に追加する。

- [ ] `MetadataWindow` の責務を「前後5件の保持」に限定する。
- [ ] `MetadataWindow` のテストで「常に 11 件以下」「範囲外が drop される」を先に書く。

### 2. フェイクと境界の整理
- [ ] `MetadataFetcher` の最小インターフェースを定義する。
- [ ] `FakeMetadataFetcher` を導入し、`RequestId` を付けた結果を返せるようにする。
- [ ] 古い `RequestId` の結果が無視されることをテストで示す。

### 3. 先行読み込みの導入
- [ ] 選択移動イベントから「前後5件」のリクエストを作る関数を追加する。
- [ ] 先行読み込みの結果が `MetadataSnapshot` に集約されることをテストする。

### 4. UI 連携
- [ ] `MetadataUpdate` のメッセージ経路を整理する。
- [ ] 取得中／エラーを示す `MetadataStatus` を UI に渡すテストを追加する。
- [ ] UI 側は明示的な再取得トリガーだけを送るように整理する。

### 5. スロットリングと優先度
- [ ] `Semaphore` を用いた同時取得数の制限を追加する。
- [ ] 高優先度／低優先度の待機キューを導入する。
- [ ] 高優先度が先に permit を取得することをテストで示す。
- [ ] 低優先度のキャンセルで permit が返ることをテストする。

### 6. キャンセルと古い結果の破棄
- [ ] `AbortHandle` 等で古い取得を中断できるようにする。
- [ ] 取得完了時の `RequestId` 照合を維持する。
- [ ] 連続移動でも最新結果のみ反映されることを統合テストで示す。

### 7. 仕上げ
- [ ] UI の表示遅延が減ることを手動確認する。
- [ ] 200 回連続移動のテストを追加し、保持件数が増えないことを確認する。

# セッション永続化と復元 (4.2)

## 1. 目的

Phase 4.2 のゴールは、終了前のタブ構成（タブ ID + パス）を記録し、再起動後に同じ作業領域へ戻せるようにすることである。現在の作業を継ぎ足すように復帰できれば、連続的な作業体験が得られ、`Value: アプリを閉じる前の状態から即座に再開できる` という要求に応える。

## 2. 保存対象

- `SessionSnapshot` は起動セッション単位の UUID、タブ一覧（`tab_id` + `path`）という最小構成を持つ。
- 選択中インデックスやソート、フィルタなどの UI に関する情報は保存対象とせず、core 層が整合性を担保する。
- `path` は文字列として保持し、存在しないパスやマウント待ちのパスは復元時の個別エラーとして扱う。

## 3. 永続化先と保存フロー

- snapshot の保存先となる「コンフィグルート」は次の優先順位で決定する:
  1. 環境変数 `OX_CONFIG_HOME` が設定されている場合はその値をホームディレクトリとして扱い、`{OX_CONFIG_HOME}/oxide` を config/セッション用のルートとする。
  2. 設定されていないならプラットフォーム標準のユーザーディレクトリ（`$HOME` または `%USERPROFILE%`）を使い、`~/.config/oxide` へフォールバックする。
-  3. どちらも取得できないケースでは作業ディレクトリ直下の `./.config/oxide` を使い、警告ログで通知する。
- `src/config.rs` の `config_path` も `OX_CONFIG_HOME` を参照しており、設定ファイルと session の保存先が同じ config ルートに揃うようになっている。
- このルートの下に `session.json` と `sessions/` 層を作り、全ての保存/読み取りを行う。
- 保存は atomic な temp ファイル → rename のステップで行い、途中でクラッシュしても破損した状態を残さない。
- `session.json` には最新の UUID、タブ一覧、暗号化に使った鍵メタ情報を含める。
- タブの追加・削除・パス変更を検出したら `SaveSession` 相当の処理をデバウンス付きでトリガーし、保存作業を過度に連続させない。
- `Ctrl+Q` や `Ctrl+C` ×2 などの終了操作時にも明示的に保存処理を走らせ、常に最新の snapshot が残るようにする。

## 4. スナップショット履歴

- 起動セッションごとに UUID（v7）を生成し、更新／終了時にコンフィグルート下の `sessions/{uuid}.json` を出力する。
- UUID v7 はタイムベースで生成され、テキストソートした順が生成順と同じになるため、追加のタイムスタンプは不要とする。
- 履歴は直近 50 世代を保持し、超過したら最古ファイルから削除する。
- 履歴ファイルの書き出しも atomic に行い、失敗した場合はログ出力で通知する。
- 履歴を参照する UI や CLI は想定していないが、将来的な recovery 用にディスク上にたどれる状態を残す。

## 5. 復元フロー

- 起動時に最初にコンフィグルートの `session.json` を読み込み、snapshot を構築する。読み込みに失敗した場合は現在の `cwd` だけをタブとして開く。
- 各パスの存在確認を行い、ネットワークドライブやマウント遅延がある場合は UI へ「接続中…」状態を送ることで、TUI が固まらずに待機中を表示できるようにする。
- 復元処理はタブ単位でエラーを扱い、存在しないパスや権限不足、暗号化やパスフレーズの不一致があっても他のタブに影響を与えない。
- 復元結果は `SessionRestoreResult` で core から UI へ通知し、スキップしたタブについてはユーザーに簡潔なメッセージを渡す。
- `session_restore` 設定を無効化している場合は snapshot を無視し、明示的な `--new` フラグや設定変更で常に直近 `cwd` を開く。

## 6. 実装詳細

- `core::session` モジュールを用意し、`SessionSnapshot`、`SessionStore`、`SessionRestoreResult` などを定義する。
- `SessionStorage` trait を定義し、ファイルベースの実装を通じて atomic な保存を行う。テストではインメモリ実装を注入する。
- JSON (de)serialization は serde で実装し、`SessionSnapshot` に `version` フィールドを持たせて将来の拡張を受け入れる。
- `SessionEncryptor` trait を分離し、AES-GCM をベースに nonce とタグを記録する。暗号化オプションは任意とし、テストではモック実装を使う。
- タブの構成変更を検知したら `SaveSession` を core に送信し、core 内で `SessionStore` を呼び出す。結果は `SessionSaved` / `SessionSaveFailed` のイベントとして UI へ返す。
- UI から `RestoreSession` を送ることで復元処理が始まり、`SessionRestoreResult` と `SessionRestoreError` を UI に配信する。
- 同じパスが複数タブにあっても素の `path` と `tab_id` を保持するため、復元後でもタブごとのコンテキストを再現できる。
- 保存頻度のデバウンスは、タブの変更直後に 500ms 程度待ち、同じ間隔に再トリガーされないように扱う。

## 7. テスト戦略

- `session.json` を生成・読み込みするユニットテストを用意し、保存した内容が再起動と同じ構成になることを確認する。
- 失敗パスや権限無し、暗号化失敗でも `SessionRestoreResult` が適切なエラーを返すテストを追加し、他のタブに影響しないことを確かめる。
- 保存処理は atomic 書き込みが正常に行われるかをテストし、`SessionStorage` の mock で rename に失敗したケースも確認する。
- 統合テストでは、終了操作（`Ctrl+Q` / `Ctrl+C`×2）後に `session.json` が更新され、再起動時に同じタブ構成が復元されるシナリオを検証する。
- ネットワークドライブ遅延のシミュレーションを組み込み、`RestoreSession` 中に UI が「接続中…」を受け取るまでの期待動作を確認する。

## 8. 受け入れ条件

1. 終了操作後にコンフィグルートの `session.json` が更新され、起動時に同じタブ構成（ID + パス）が復元される。
2. タブ構成の変更後、コンフィグルート下の `sessions/{uuid}.json`（UUID v7 を使用）に履歴が記録され、50 世代を超えると最古が削除される。
3. 暗号化オプションを有効にした場合に保存ファイルが復号なしでは読めず、正しいパスフレーズで起動すると復元に成功する。
4. 復元に失敗したタブはスキップされるが、他のタブで作業を続けられる。
5. 復元中に遅延するパスは UI で「接続中…」などのフィードバックを受け取り、UI 全体が固まらない。

## 9. 制約事項

- セッションファイルにファイル内容や環境変数などの機密情報は含めない。ただし非暗号化時にパス文字列が露出する。
- 暗号化はオプションとし、パスフレーズを忘れた場合のリカバリは提供しない。
- 履歴保存はローカルディスクのみで、クラウド同期等は含まない。
- コンフィグルート（`OX_CONFIG_HOME` で指定したルート、または `~/.config/oxide`）ディレクトリがなければ自動で作成する。アクセス権がなく保存できない場合は UI にエラー通知を出す。

# セッション永続化と復元 (4.2)

## 1. 目的

Phase 4.2 のゴールは、終了前のタブ構成（タブ ID + パス）を記録し、再起動後に同じ作業領域へ戻せるようにすることである。現在の作業を継ぎ足すように復帰できれば、連続的な作業体験が得られ、`Value: アプリを閉じる前の状態から即座に再開できる` という要求に応える。

## 2. 保存対象

- `SessionSnapshot` は起動セッション単位の UUID、タブ一覧（`tab_id` + `path`）という最小構成を持つ。タブの順序も保持し、最終セッション保存時に開いていたタブ構成を再現できるようにする。
- 選択中インデックスやソート、フィルタなどの UI に関する情報は保存対象とせず、core 層が整合性を担保する。
- タブに明示的に割り当てられたカラーテーマ（存在する場合）だけを付加情報として記録する。その他の情報は後続作業の「補足」に過ぎないため管理対象に含めない。
- `path` は文字列として保持し、存在しないパスやマウント待ちのパスは復元時の個別エラーとして扱う。

## 3. 永続化先と保存フロー

- snapshot の保存先となる「コンフィグルート」は次の優先順位で決定する:
  1. 環境変数 `OX_CONFIG_HOME` が設定されている場合はその値をルートとして使い、`{OX_CONFIG_HOME}/oxide` を config/セッション用ディレクトリとする。
  2. 設定されていないならプラットフォーム標準のユーザーディレクトリ（`$HOME` または `%USERPROFILE%`）を使い、`~/.config/oxide` をルートとする。
  3. 以上のいずれかでルートを確定した後、書き込みアクセスがないときはユーザーへ通知し、`OX_CONFIG_HOME` を設定して適切な権限をもつディレクトリを指定するよう促す。追加のフォールバック先は試行しない。
- `src/config.rs` の `config_path` も `OX_CONFIG_HOME` を参照しており、設定ファイルと session の保存先が同じ config ルートに揃うようになっている。
- このルートの下に `session.json` と `sessions/` 層を作り、全ての保存/読み取りを行う。
- 保存は atomic な temp ファイル → rename のステップで行い、途中でクラッシュしても破損した状態を残さない。
- `session.json` には最新の UUID とタブ一覧など、復元に必要な最小限のメタデータを含める。暗号化や鍵管理の詳細は別 Spec で定義する予定であり、本ドキュメントでは TODO の位置にとどめる。
- タブの追加・削除・パス変更を検出したら `SaveSession` 相当の処理をデバウンス付きでトリガーし、保存作業を過度に連続させない。
- `Ctrl+Q` や `Ctrl+C` ×2 などの終了操作時にも明示的に保存処理を走らせ、常に最新の snapshot が残るようにする。
- コンフィグルートの書き込み権限チェック後に保存処理が失敗した場合は UI にエラーを通知するが、保存できなかった状態のまま処理を続行する。高速終了を優先するため、失敗でプロセスを止めず、ログ出力＋再試行を掛けるレットで問題をヘッジする。

## 4. スナップショット履歴

- 起動セッションごとに UUID（v7）を生成し、更新／終了時にコンフィグルート下の `sessions/{uuid}.json` を出力する。
- UUID v7 はタイムベースで生成され、テキストソートした順が生成順と同じになるため、追加のタイムスタンプは不要とする。
- 履歴は直近 50 世代を保持し、超過したら最古ファイルから削除する。
- 履歴ファイルの書き出しも atomic に行い、失敗した場合はログ出力で通知する。
- 履歴を参照する UI や CLI は想定していないが、将来的な recovery 用にディスク上にたどれる状態を残す。

## 5. 復元フロー

- 起動時に最初にコンフィグルートの `session.json` を読み込み、snapshot を構築する。読み込みに失敗した場合は現在の `cwd` だけをタブとして開く。
- 復元処理はタブ単位でエラーを扱い、存在しないパスや権限不足があっても他のタブに影響を与えない。
- 復元結果は `SessionRestoreResult` で core から UI へ通知し、スキップしたタブについてはユーザーに簡潔なメッセージを渡す。
- `session_restore` 設定を無効化している場合は snapshot を無視する。`session_restore` が有効でも、`--in-private`を指定した起動では常に既存セッションをスキップして InPrivate セッションとして立ち上がるため、こちらが優先される。

`SessionRestoreResult` は UI にイベントを流すための契約であり、基本的にユーザーへの通知は不要とする。初回起動時に「セッションを復元しました」程度の短いバナーを出すだけで十分で、各タブの skipped/failed 情報を個別に通知するような UI は想定しない。

`SaveSession` 相当の保存トリガーは変更直後に 500ms 程度デバウンスして走る。例外的な連続タブ変更や終了タイミングにおいて保存に失敗しても、アプリの高速終了を優先し、例外的にログ通知するのみで処理を止めない（`SessionSaveFailed` イベントは UI に渡す）。実行中に既存保存がある場合は上書きせず new UUID の snapshot へ移るようにして、保存中ロードを防ぐ。

### 5.1 `session_restore` と CLI フラグの優先度

| 状態 | 挙動 | 備考 |
| --- | --- | --- |
| `session_restore` 設定 `false` | 既存 snapshot を無視し、明示的に `cwd` を開く | 設定が最優先 |
| `--in-private` 起動 | 常に InPrivate セッションとして起動し、既存 session.json を無視 | CLI フラグが設定より上位 |
| 上記未満（デフォルト） | snapshot を復元し、前回タブ構成へ復帰 | `session_restore` が `true` の想定 |


## 6. 実装詳細

- `core::session` モジュールを用意し、`SessionSnapshot`、`SessionStore`、`SessionRestoreResult` などを定義する。
- `SessionStorage` trait を定義し、ファイルベースの実装を通じて atomic な保存を行う。テストではインメモリ実装を注入する。
- JSON (de)serialization は serde で実装し、`SessionSnapshot` に `version` フィールドを持たせて将来の拡張を受け入れる。
- 暗号化にまつわる要件やインターフェースは別 Spec で整理する予定で、本 Spec では core の記録と復元の契約に集中する。
- タブの構成変更を検知したら `SaveSession` を core に送信し、core 内で `SessionStore` を呼び出す。結果は `SessionSaved` / `SessionSaveFailed` のイベントとして UI へ返す。
- UI から `RestoreSession` を送ることで復元処理が始まり、`SessionRestoreResult` と `SessionRestoreError` を UI に配信する。
- 同じパスが複数タブにあっても素の `path` と `tab_id` を保持するため、復元後でもタブごとのコンテキストを再現できる。
- 保存頻度のデバウンスは、タブの変更直後に 500ms 程度待ち、同じ間隔に再トリガーされないように扱う。

### 6.1 core と UI の責務整理

- core 側は `SaveSession` / `RestoreSession` イベントの受信に応じて `SessionStore` を呼び出し、トランザクション的に `session.json` と `sessions/{uuid}.json` を更新する。書き込み失敗は `SessionSaveFailed`、`SessionRestoreError` で伝搬し、UI は必要に応じて再送やログ出力のみを行う。
- UI 側は `SessionSaved` / `SessionRestoreResult` を受け取って status 表示を更新するが、成功時のバナーやダイアログは簡潔に留め、エラーが発生してもユーザー操作を阻害しない方向で扱う。

## 7. テスト戦略

- `session.json` を生成・読み込みするユニットテストを用意し、保存した内容が再起動と同じ構成になることを確認する。
- 失敗パスや権限無しなどのケースで `SessionRestoreResult` が適切なエラーを返すテストを追加し、他のタブに影響しないことを確かめる。
- 保存処理は atomic 書き込みが正常に行われるかをテストし、`SessionStorage` の mock で rename に失敗したケースも確認する。
- 統合テストでは、終了操作（`Ctrl+Q` / `Ctrl+C`×2）後に `session.json` が更新され、再起動時に同じタブ構成が復元されるシナリオを検証する。

## 8. 受け入れ条件

1. 終了操作後にコンフィグルートの `session.json` が更新され、起動時に同じタブ構成（ID + パス）が復元される。
2. タブ構成の変更後、コンフィグルート下の `sessions/{uuid}.json`（UUID v7 を使用）に履歴が記録され、50 世代を超えると最古が削除される。
3. （TODO: 暗号化 Spec で整理予定）
4. 復元に失敗したタブはスキップされるが、他のタブで作業を続けられる。

## 9. 制約事項

- セッションファイルにファイル内容や環境変数などの機密情報は含めない。ただし非暗号化時にパス文字列が露出する。
- 暗号化はオプションとし、パスフレーズを忘れた場合のリカバリは提供しない。
- 履歴保存はローカルディスクのみで、クラウド同期等は含まない。
- コンフィグルート（`OX_CONFIG_HOME` で指定したルート、または `~/.config/oxide`）ディレクトリがなければ自動で作成する。書き込みアクセスがない場合は UI にエラー通知して `OX_CONFIG_HOME` を設定し、適切な権限を持つディレクトリを指定するよう促す。別のフォールバック先は試行しない。

## TODO リスト（最小ユーザー価値の分割）

- [x] `session.json` を読み込み、タブ 1 つだけでも復元できるようにする。
- [x] `session.json` が無い場合は `cwd` を 1 タブで開く。
- [x] タブ構成の変更と `cd` のタイミングで `session.json` を保存する。
- [x] 保存をデバウンスして連続書き込みを抑える。
- [x] 終了操作で最後の保存を行い、復元結果が最新になるようにする。
- [x] 複数タブの復元。
- [x] カラーテーマの保存。
- [x] 存在しないパスはスキップし、復元可能なタブだけを開く。
- [x] `sessions/{uuid}.json` の履歴保存（UUID v7・50世代削除・atomic）
- [x] `session.json` の `version` / `session_id` の正式運用（UUID生成）
- [x] 保存先のパス決定を `OX_CONFIG_HOME` 優先で実装し、作成できなければユーザーへ通知する。
- [ ] `--in-private` と `session_restore=false` のときは復元をスキップする。
- [ ] `SessionRestoreResult` / `SessionSaveFailed` を core→UI のイベントとして実装する。
- [x] 保存失敗時の UI 通知（ログ/簡易バナー）。
